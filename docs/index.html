<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ROM Patcher</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>
    <div class="theme-toggle">
        <button id="themeToggle">üåô</button>
    </div>
    <div class="container">
        <nav class="breadcrumb">
            <a href="../">‚Üê Home</a>
        </nav>
        <h1>üéÆ ROM Patcher</h1>
        
        <div class="section">
            <h2>üì¶ Select Patch</h2>
            <select id="patchSelect">
                <option value="">Loading patches...</option>
            </select>
            <div id="patchInfo" class="patch-info"></div>
        </div>
        
        <div class="section">
            <h2>üíæ Select ROM File</h2>
            <input type="file" id="romFile" accept=".gb,.gbc,.gba,.nes,.smc,.sfc,.z64,.n64">
            <div id="romValidation"></div>
        </div>
        
        <div id="changelogSection" class="section" style="display:none">
            <h2>üìã Patch Information</h2>
            <div id="changelogContent"></div>
        </div>
        
        <div class="section">
            <button id="patchButton" disabled>üöÄ Apply Patch</button>
        </div>
        
        <div id="status"></div>
    </div>
    
    <script src="js/rompatcher.min.js"></script>
    <script src="js/RomPatcher.webapp.js"></script>
    <script>
        let patches = [];
        let selectedPatch = null;
        
        // CRC32 calculation
        function crc32(data) {
            const table = new Uint32Array(256);
            for (let i = 0; i < 256; i++) {
                let c = i;
                for (let j = 0; j < 8; j++) {
                    c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
                }
                table[i] = c;
            }
            let crc = 0xFFFFFFFF;
            for (let i = 0; i < data.length; i++) {
                crc = table[(crc ^ data[i]) & 0xFF] ^ (crc >>> 8);
            }
            return ((crc ^ 0xFFFFFFFF) >>> 0).toString(16).toUpperCase().padStart(8, '0');
        }
        
        // Load manifest
        fetch('manifest.json')
            .then(r => r.json())
            .then(data => {
                patches = data;
                const select = document.getElementById('patchSelect');
                select.innerHTML = '<option value="">Choose a patch...</option>';
                patches.forEach(patch => {
                    const option = document.createElement('option');
                    option.value = patch.id;
                    option.textContent = patch.name;
                    select.appendChild(option);
                });
            });
        
        document.getElementById('patchSelect').addEventListener('change', function(e) {
            selectedPatch = patches.find(p => p.id === e.target.value);
            
            // Show patch info
            const patchInfo = document.getElementById('patchInfo');
            const changelogSection = document.getElementById('changelogSection');
            const changelogContent = document.getElementById('changelogContent');
            
            if (selectedPatch) {
                patchInfo.innerHTML = `
                    <div class="patch-details">
                        <span class="patch-type">${selectedPatch.type.toUpperCase()}</span>
                        ${selectedPatch.crc32 ? `<span class="patch-crc">CRC32: ${selectedPatch.crc32}</span>` : ''}
                    </div>
                `;
                
                if (selectedPatch.changelog) {
                    changelogContent.innerHTML = marked.parse(selectedPatch.changelog);
                    changelogSection.style.display = 'block';
                } else {
                    changelogSection.style.display = 'none';
                }
            } else {
                patchInfo.innerHTML = '';
                changelogSection.style.display = 'none';
            }
            
            validateRom();
            updatePatchButton();
        });
        
        document.getElementById('romFile').addEventListener('change', function() {
            validateRom();
            updatePatchButton();
        });
        
        function validateRom() {
            const romFile = document.getElementById('romFile').files[0];
            const validation = document.getElementById('romValidation');
            
            if (!romFile || !selectedPatch || !selectedPatch.crc32) {
                validation.innerHTML = '';
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const romData = new Uint8Array(e.target.result);
                const calculatedCrc = crc32(romData);
                
                if (calculatedCrc === selectedPatch.crc32) {
                    validation.innerHTML = '<div class="validation-success">‚úì ROM validated</div>';
                } else {
                    validation.innerHTML = '<div class="validation-error">‚ö† ROM CRC32 mismatch. Expected: ' + selectedPatch.crc32 + ', Got: ' + calculatedCrc + '</div>';
                }
            };
            reader.readAsArrayBuffer(romFile);
        }
        
        document.getElementById('patchButton').addEventListener('click', function() {
            const romFile = document.getElementById('romFile').files[0];
            if (!romFile || !selectedPatch) return;
            
            document.getElementById('status').textContent = 'Patching...';
            
            fetch(selectedPatch.file)
                .then(r => r.arrayBuffer())
                .then(patchData => {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const romBinFile = new BinFile(new Uint8Array(e.target.result));
                            romBinFile.fileName = romFile.name;
                            
                            const patchBinFile = new BinFile(new Uint8Array(patchData));
                            const patch = RomPatcher.parsePatchFile(patchBinFile);
                            
                            if (!patch) {
                                throw new Error('Invalid patch file format');
                            }
                            
                            const patchedRom = RomPatcher.applyPatch(romBinFile, patch);
                            
                            const blob = new Blob([patchedRom.getBytes()], {type: 'application/octet-stream'});
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = patchedRom.fileName;
                            a.click();
                            URL.revokeObjectURL(url);
                            
                            document.getElementById('status').textContent = '‚úÖ Patch applied successfully!';
                        } catch (err) {
                            document.getElementById('status').textContent = '‚ùå Error: ' + err.message;
                            console.error('Patching error:', err);
                        }
                    };
                    reader.readAsArrayBuffer(romFile);
                })
                .catch(err => {
                    document.getElementById('status').textContent = '‚ùå Error loading patch: ' + err.message;
                });
        });
        
        function updatePatchButton() {
            const hasRom = document.getElementById('romFile').files.length > 0;
            const hasPatch = selectedPatch !== null;
            document.getElementById('patchButton').disabled = !(hasRom && hasPatch);
        }
        
        // Dark mode toggle
        document.getElementById('themeToggle').addEventListener('click', function() {
            document.body.classList.toggle('dark-mode');
            const isDark = document.body.classList.contains('dark-mode');
            this.textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
            localStorage.setItem('darkMode', isDark);
        });
        
        // Set dark mode as default
        if (localStorage.getItem('darkMode') === null) {
            localStorage.setItem('darkMode', 'true');
        }
        
        if (localStorage.getItem('darkMode') === 'true') {
            document.body.classList.add('dark-mode');
            document.getElementById('themeToggle').textContent = '‚òÄÔ∏è';
        }
    </script>
</body>
</html>